---
- name: Download Kibana tarball.
  get_url:
    url: https://download.elastic.co/kibana/kibana/kibana-{{ elk_kibana_version }}-linux-x64.tar.gz
    dest: /opt/kibana-{{ elk_kibana_version }}-linux-x64.tar.gz
    # Don't download file every time, only if it doesn't exist.
    force: no

- name: Check for existing Kibana installation.
  stat:
    path: /opt/kibana-{{ elk_kibana_version }}-linux-x64
  register: kibana_directory_check

  # It's important to configure the init file first, since it notifies daemon-reload.
  # This task must come before any task in the same play that will notify `restart kibana`,
  # since Ansible queues handlers in the order they were notified. We want to ensure that if
  # kibana is being restarted AND the service file changed, daemon-reload runs first.
- name: Create Kibana systemd service file.
  template:
    src: kibana.service.j2
    dest: /etc/systemd/system/kibana.service
    owner: root
    group: root
    mode: "0644"
  notify:
    - reload systemd
    - restart kibana

- name: Extract Kibana tarball.
  unarchive:
    copy: no
    src: /opt/kibana-{{ elk_kibana_version }}-linux-x64.tar.gz
    dest: /opt/
    owner: "{{ elk_nginx_user }}"
    group: "{{ elk_nginx_user }}"
  when: kibana_directory_check.stat.exists == false

- name: Symlink Kibana directory.
  file:
    state: link
    dest: /opt/kibana
    src: /opt/kibana-{{ elk_kibana_version }}-linux-x64
    owner: "{{ elk_nginx_user }}"
    group: "{{ elk_nginx_user }}"

  # Two-pass approach to creating logfile idempotently. Create the empty logfile
  # if none exists (force: no), but to ensure permissions we need a second task.
- name: Create logfile for Kibana.
  copy:
    dest: "{{ elk_kibana_logfile }}"
    owner: root
    group: "{{ elk_nginx_user }}"
    mode: "0660"
    force: no
    content: ""
  # The default value is 'stdout', which when running as a service dumps to syslog.
  # Run a sanity check for a leading slash, then assume we have an absolute path and
  # proceed with creating the logfile.
  when: elk_kibana_logfile.startswith('/')
  notify: restart kibana

  # Force permissions on logfile, even if previous copy task backed off.
- name: Set permissions on logfile for Kibana.
  file:
    path: "{{ elk_kibana_logfile }}"
    owner: root
    group: "{{ elk_nginx_user }}"
    mode: "0660"
  when: elk_kibana_logfile.startswith('/')
  notify: restart kibana

- name: Update Kibana config file.
  lineinfile:
    dest: /opt/kibana/config/kibana.yml
    regexp: "{{ item.regexp }}"
    line: "{{ item.line }}"
    state: present
  with_items:
    - regexp: '^server\.host'
      line: 'server.host: "localhost"'
    - regexp: '^kibana\.defaultAppId:'
      line: 'kibana.defaultAppId: "{{ elk_kibana_default_app }}"'
    - regexp: '^logging\.dest:'
      line: 'logging.dest: "{{ elk_kibana_logfile }}"'
  notify: restart kibana

- name: Look up Kibana saved objects.
  set_fact:
    kibana_objects: "{{ lookup('file', role_path+'/files/kibana-dashboards.json') }}"

- debug: var=kibana_objects

- name: Import Kibana dashboards.
  uri:
    url: "http://localhost:9200/.kibana/dashboard/{{ item._id }}"
    method: PUT
    body: "{{ item._source | to_nice_json }}"
    status_code: 200
    body_format: json
  with_items: "{{ kibana_objects|kibana_dashboards }}"

- name: Import Kibana searches.
  uri:
    url: "http://localhost:9200/.kibana/search/{{ item._id }}"
    method: PUT
    body: "{{ item._source }}"
    status_code: 200
    body_format: json
  with_items: "{{ kibana_objects|kibana_searches }}"

- name: Import Kibana visualizations.
  uri:
    url: "http://localhost:9200/.kibana/visualization/{{ item._id }}"
    method: PUT
    body: "{{ item._source | to_nice_json }}"
    status_code: 200
    body_format: json
  with_items: "{{ kibana_objects|kibana_visualizations }}"

- name: Start kibana service.
  service:
    name: kibana
    state: running
    enabled: yes
