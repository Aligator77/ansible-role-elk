filter {
  if [type] == "redmine" {
    multiline {
      # Redmine logs can be single line or multiline. In the multiline format,
      # lines 2 and higher of the multiline event will be indented by two spaces.
      pattern => "^\s"
      what => "previous"
    }
    grok {
      match => {"message" => "%{REDMINE_PLUGIN_INFO}" }
      add_tag => "resource_request"
    }
    if "resource_request" in [tags] {
      # Example multiline log output to parse:
      # Processing by AdminController#plugins as HTML
      #   Current user: kevin (id=6)
      #   Rendered admin/plugins.html.erb within layouts/admin (15.9ms)
      #   Rendered admin/_menu.html.erb (10.5ms)
      #   Rendered plugins/redmine_tweaks/app/views/application/_global_header.erb (90.5ms)
      #   Rendered plugins/redmine_tweaks/app/views/application/_global_content.erb (0.3ms)
      #   Rendered plugins/redmine_tweaks/app/views/application/_global_footer.erb (0.3ms)
      #   Rendered layouts/base.html.erb (158.0ms)
      mutate {
        # Preserve the unmodified raw message in a separate field, prior to munging.
        add_field => { "original_message" => "%{message}" }
      }
      grok {
        match => { "message" => "%{REDMINE_CURRENT_USER}" }
      }
      ruby {
        # Ungodly ruby code to create a list of the "Rendered" lines and store as array.
        code => 'event["resources"] = event["message"].split("\n")[1..-1].select { |r| /^\s*Rendered/ =~ r }.map { |r| r.gsub!(/^\s*/, "") }'
      }
      ruby {
        # The firstline of multiline output is our best bet for the "message" field
        code => 'event["message"] = event["message"].split("\n")[0]'
      }
      mutate {
        remove_tag => "_grokparsefailure"
      }
    }

    else {
      grok {
        # Matches the following examples:
        # Failed login for 'sadaskdhas' from 208.70.28.120 at 2016-01-12 23:23:51 UTC
        # Failed login for 'kevin' from 50.1.125.58 at 2016-01-25 23:03:21 UTC
        match => { "message" => "%{REDMINE_FAILED_LOGIN}" }
        add_tag => "failed_login"
      }
      grok {
        # Successful authentication for 'kevin' from 208.70.28.120 at 2015-12-17 20:13:47 UTC
        # Successful authentication for 'conor' from 24.61.12.145 at 2016-01-12 19:30:52 UTC
        # Successful authentication for 'garrettr' from 50.1.125.58 at 2016-01-12 21:46:07 UTC
        # Successful authentication for 'admin' from 50.1.125.58 at 2016-01-26 00:28:16 UTC
        match => {"message" => "%{REDMINE_SUCCESSFUL_LOGIN}"}
        add_tag => "successful_login"
      }
      grok {
        # matches:
        # MailHandler: received email from kevin@transparencytoolkit.org with Message-ID 56A7F6F1.2050403@transparencytoolkit.org: encrypted=true, valid=false, ignored=true
        # MailHandler: received email from kevingallagher@gmail.com with Message-ID 56A7F7D9.1040807@gmail.com: encrypted=false, valid=false, ignored=true
        match => {"message" => "%{REDMINE_MAIL}" }
        add_tag => "email_received"
      }
      grok {
        # Matches:
        # No public key found for Garrett Robinson <garrett@freedom.press> (3)
        # No public key found for Conor Schaefer <conor@freedom.press> (7)
        match => {"message" => "%{REDMINE_NO_PUBKEY}" }
        add_tag => "missing_public_key"
      }
    }
  }
}
